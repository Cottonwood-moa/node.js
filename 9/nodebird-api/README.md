이 장에서는 NodeBird 앱의 REST API 서버를 만들어보자.
노드는 자바스크립트 문법을 사용하므로 웹 API 서버에서 데이터를 전달할 때 시용히는 JSON을 100% 활용하기에 좋다.
API 서버는 프런트엔드와 분리되어 운영되므로 모바일 서버로도 활용 가능하다.
노드를 모바일 서버로 사용하려면 이번 장과 같이 서버를 REST API 구조로 구성하면 된다.
특히 JWT토큰은 모바일 앱과 노드 서버 간에 사용자 인증을 구현할 때 자주 사용된다.
사용자 인증, 사용량 제한 등의 기능을 구현하여 NodeBird 의 웹 API 서버를 만들어보자.
이번장을 위해 NodeBird 앱에 게시글을 다양하게 올려두자.

## API 서버 이해하기
먼저 API 와 웹 API 서버의 개념을 알아보자.
API 는 Application Programming Interface 의 두문자어로, 다른 애플리케이션에서 현재 프로그램의 기능을 사용할 수 있게 허용하는 접점을 의미한다.
웹 API 는 다른 웹 서비스의 기능을 사용하거나 자원을 가져올 수 있는 창구이다.
흔히 API 를 '열었다' 또는 '만들었다' 라고 표현하는데 , 이는 다른 프로그램에서 현재 현재 기능을 사용할 수 있게 허용했음을 의미한다.
다른 사람에게 정보를 제공하고 싶은 부분만 API 를 열어놓고, 제공하고 싶지 않은 부분은 API 를 만들지 않는 것이다.
또한, API 를 열어놓았다고 해서 모든 사람이 정보를 가져갈 수 있다는 뜻이 아니라 인증된 사람만 일정 횟수 내에서 가져가게 제한을 둘 수도 있다.
위와 같은 서버에 API 를 올려서 URL 을 통해 접근할 수 있게 만든 것을 웹 API 서버라고 한다.
이 장에서 만들 서버도 NodeBird의 정보를 제공하는 웹 API 이다.
단, 정보를 모든 사람이 아닌 인증된 사용자에게만 제공할 것이다.

여기서 크롤링 이라는 개념을 알아두면 좋다.
크롤링을 해서 웹 사이트의 데이터를 수집했다는 말을 들어본 적이 있을 것이다.
크롤링은 웹 사이트가 자체적으로 제공하는 API 가 없거나 API 이용에 제한이 있을 때 사용하는 방법이다.
표면적으로 보이는 웹 사이트의 정보를 일정 주기로 수집해 자체적으로 가공하는 기술이다.
하지만 웹 사이트에서 직접 제공하는 API 가 아니므로 원하는 정보를 얻지 못할 가능성이 있다.
또한, 웹 사이트에서 제공하길 원치 않는 정보를 수집한다면 법적인 문제가 생길 수도 있다.
서비스 제공자 입장에서도 주기적으로 크롤링을 당하면 웹 서버의 트래픽이 증가하여 서버에 무리가 가므로, 웹 서비스를 만들 때 공개해도 되는 정보들은 API 로 만들어 API 를 통해 가져가게 하는 것이 좋다.

## 프로젝트 구조 갖추기
이번 프로젝트는 NodeBird 서비스와 데이터베이스를 공유한다.
다른 서비스가 NodeBird 의 데이터나 서비스를 이용할 수 있도록 창구를 만드는 것이므로 프런트 쪽은 거의 다루지 않는다.
우리는 다른 서비스에 NodeBird 서비스의 게시글, 해시태그, 사용자 정보를 JSON 형식으로 제공할 것이다.
단, 인증을 받은 사용자에게만 일정한 할당량 안에서 API 를 호출할 수 있도록 허용할 것이다.

우선 NodeBird-api 폴더를 만들고 package.json 파일을 생성한다.
npm init 으로 생성한 후 dependencies 들을 설치해도 되고 깃허브에서 복사해도 된다.
새로 추가된 패키지는 uuid 이며, 고유한 랜덤 문자열을 만들어내는 데 사용된다.

    npm i bcrypt cookie-parser dotenv morgan mysql2 nunjucks passport passport-kakao passport-local sequelize uuid express express-session
    npm i -D nodemon

NodeBird 에서 config, models, passport 폴더와 내용물들을 모두 복사해서 nodebird-api 폴더에 붙여 널는다.
routes 폴더에서는 auth.js 와 middlewares.js 만 그대로 사용한다.
마지막으로 .env 파일을 복사한다.
다른 폴더와 파일은 새로 나올 때마다 직접 생성하면 된다.

다음은 에러를 표시할 파일이다.
views 폴더를 만들고 그 폴더 안에 error.html 파일을 생성한다.

    error.html

    app.js

포트 번호를 8002 로 했으므로 9장의 NodeBird 앱 서버 및 추후에 만들 클라이언트인 NodeDog 서버와 같이 실행할 수 있다.
콘솔을 하나 더 열어서 서버를 실행하면 된다.

도메인을 등록하는 기능이 새로 생겼으므로 도메인 모델을 추가해보자.
도메인은 인터넷 주소를 뜻한다.

    models/domian.js

도메인 모델에는 인터넷 주소(host)와 도메인 종류(type), 클라이언트 비밀 키 (clientSecret)이 들어간다.

type 컬럼을 보면 처음 보는 ENUM 이라는 속성을 갖고 있다. 
넣을 수 있는 값을 제한하는 데이터 형식이다. 
무료 (free)나 프리미엄(premium)중에서 하나의 종류만 선택할 수 있게 했고, 이를 어겼을 때 에러가 발생한다.

클라이언트 비밀 키는 다른 개발자들이 NodeBird 의 API 를 사용할 때 필요한 비밀 키이다.
이 키가 유출되면 다른 사람을 사칭해서 요청을 보낼 수 있으므로, 유출되지 않도록 주의해야 한다.
한 가지 안전 장치로서,  요청을 보낸 도메인까지 일치해야 요청을 보낼 수 있게 제한을 둘 것이다.
clientSecret 컬럼은 UUID라는 타입을 가진다.
UUID 는 충돌 가능성이 매우 적은 랜덤한 문자열이다.

이제 새로 생성한 도메인 모델을 시퀄라이즈와 연결한다.
사용자 모델과 일대다 관계를 가지는데, 사용자 한 명이 여러 도메인을 소유할 수도 있기 때문이다.

    models/index.js (수정)
    models/user.js (수정)

다음은 로그인하는 화면이다.
카카오 로그인은 제외했다.
카카오 로그인을 추가하려면 카카오 개발자 사이트에서 로컬 8002 도메인을 추가해야 한다.

    views/login.html

다음은 도메인을 등록하는 화면이다.
로그인하지 않았다면 로그인 창이 먼저 뜨고, 로그인한 사용자에게는 도메인 등록 화면을 보여준다.

    routes/index.js

GET /라우터와 도메인 등록 라우터(POST /domain)이다.
GET /는 접속 시 로그인 화면을 보여주며, 도메인 등록 라우터는 폼으로부터 온 데이터를 도메인 모델에 저장한다.

도메인 등록 라우터에서는 clientSecret 의 값을 uuid 패키지를 통해 생성한다.
uuid 중에서도 4버전을 사용한다.
36자리 문자열 형식으로 생겼다.
세 번째 마디의 첫 번째 숫자 4가 버전을 알려준다.
const { v4: uuidv4 }부분이 특이한데, 패키지의 변수나 함수를 불러올 때 이름을 바꿀 수 있다.
v4에서 uuidv4로 바꾸었다.

이제 서버를 실행하고 8002 포트로 접속한다.
지금부터 NodeBird API가 아니라 API 서비스를 사용하는 사용자의 입장이다.
API 를 사용하기 위해서는 허가를 받아야 한다.
카카오 로그인을 하기 위해 카카오 개발자 사이트에 애플리케이션을 만들었던 것과 비슷한 상황이다.

사용자 정보는 NodeBird 앱과 공유하므로 NodeBird 앱의 아이디로 로그인하면 된다.
카카오 로그인은 제외했으니 로컬로 가입한 이메일을 통해 로그인 한다.
로그인 후에는 도메인 등록 화면이 뜬다.

도메인을 등록하는 이유는 등록한 도메인에서만 API 를 사용할 수 있게 하기 위해서다.
웹 브라우저에서 요청을 보낼 때 , 응답을 하는 곳과 도메인이 다르면 CORS 에러가 발생할 수 있다.
브라우저가 현재 웹 사이트에서 미리 허용할 도메인을 등록해야 한다.
서버에서 서버로 요청을 보내는 경우에는 CORS 문제가 발생하지 않는다.
CORS 는 브라우저에서 발생하는 에러이기 때문이다.
이에 대해서는 10.7 절에서 자세히 다룬다.
무료와 프리미엄은 나중에 사용량 제한을 구현하기 위한 구분 값이다.
프리미엄 도메인에는 더 많은 사용량을 허가할 것이다.

이제 localhost:4000 도메인을 등록한다.
NodeBird API 를 사용할 도메인 주소이며, 다른 개발자들이 만든 서버라고 생각하면 된다.
클라이언트 비밀 키는 랜덤한 문자열이므로 각각 다르다.

발급받은 비밀 키는 localhost:4000 서비스에서 NodeBird API 를 호출할 때 인증 용도로 사용한다.
비밀 키가 유출되면 다른 사람이 호출한 것처럼 API 를 사용할 수 있으므로 조심해야 한다.

## JWT 토근으로 인증하기

다시 API 서비스를 제공하는 입장이 되어보자.
NodeBird 앱이 아닌 다른 클라이언트가 NodeBird의 데이터를 가져갈 수 있게 해야 하는 만큼 별도의 인증 과정이 필요하다.
이 책은 JWT 토큰으로 인증하는 방법을 사용한다.
JWT 는 JSON Web Token 의 약어로, JSON 형식의 데이터를 저장하는 토큰이다.
JWT는 다음과 같이 세 부분으로 구성되어 있다.

    헤더(HEADER): 토큰 종류와 해시 알고리즘 정보가 들어 있다.
    페이로드(PAYLOAD): 토큰의 내용물이 인코딩된 부분이다.
    시그니처(SIGNATURE): 일련의 문자열이며, 시그니처를 통해 토큰이 변조되었는지 여부를 확인할 수 있다.

시그니처는 JWT 비밀 키로 만들어진다.
이 비밀 키가 노출되면 JWT 토큰을 위조할 수 있으므로 비밀 키를 철저히 숨겨야 한다.
시그니처 자체는 숨기지 않아도 된다.
비밀 키를 사용하는 방법은 나중에 알아보자.

    JWT 토큰 예시
    fhjewuiohgnkmlsdvhuioedhngklwrehgowrjgkljn.fhuewifbnmksdhfuewhflm

JWT 에는 민감한 내용을 넣으면 안된다.
내용을 볼 수 있기 때문이다.
JWT 토큰이 매우 복잡해 보이지만 jwt.io 같은 사이트에서 내용을 쉽게 확인할 수 있다.
그럼 내용이 노출되는 토큰을 왜 사용하는 걸까?
모순적이지만, 내용이 들어 있기 때문이다.
만약 내용이 없는 랜덤한 토큰이라고 생각해보자.
랜덤한 토큰을 받으면 토큰의 주인이 누구인지, 그 사람의 권한은 무엇인지를 매 요청마다 체크해야 한다.
이러한 작업은 보통 데이터베이스를 조회해아 하는 복잡한 작업인 경우가 많다.
JWT 토큰은 JWT 비밀 키를 알지 않는 이상 변조가 불가능하다.
변조한 토큰은 시그니처를 비밀 키를 통해 검사할 때 들통난다.
변조할 수 없으므로 내용물이 바뀌지 않았는지 걱정할 필요가 없다.
다시 말하면 내용물을 믿고 사용할 수 있다.
즉, 사용자 이름, 권한 같은 것을 넣어두고 안심하고 사용해도 된다는 것이다.
단, 외부에 노출되어도 좋은 정보에 한해서이다.
비밀번호를 제외하고 사용자의 이메일이나 사용자의 권한 같은 것들을 넣어두면 데이터베이스 조회 없이도 그 사용자를 믿고 권한을 줄 수 있다.

JWT 토큰의 단점은 용량이 크다는 것이다.
내용물이 들어 있으므로 랜덤한 토큰을 사용할 때와 비교해서 용량이 클 수밖에 없다.
매 요청 시 토큰이 오고 가서 데이터양이 증가한다.
이렇게 장단점이 뚜렷하므로 적절한 경우에 사용하면 좋다.
비용을 생각하면 판단하기 쉽다.
랜덤 스트링을 사용해서 매번 사용자 정보를 조회하는 작업의 비용이 더 큰지, 내용물이 들어있는 JWT 토큰을 사용해서 발생하는 데이터 비용이 더 큰지 비교하면 된다.
이제 웹 서버에 JWT 토큰 인증 과정을 구현해보자.
먼저 JWT 모듈을 설치한다.

    npm i jsonwebtoken

이제 JWT 를 사용해서 본격적으로 API 를 만들어보자.
다른 사용자가 API 를 쓰려면 JWT 토큰을 발급받고 인증받아야 한다.
이는 대부분의 라우터에 공통적으로 해당하는 부분이므로 미들웨어로 만들어두는 게 좋다.


    const jwt = require('jsonwebtoken');

    ...

    exports.verifyToken = (req, res, next) => {
        try {
        req.decoded = jwt.verify(req.headers.authorization, process.env.JWT_SECRET);
        return next();
        } catch (error) {
        if (error.name === 'TokenExpiredError') { // 유효기간 초과
            return res.status(419).json({
            code: 419,
            message: '토큰이 만료되었습니다',
            });
        }
        return res.status(401).json({
            code: 401,
            message: '유효하지 않은 토큰입니다',
        });
        }
    };

요청 헤더에 저장된 토큰(req.headers.authorization)을 사용한다.
사용자가 쿠키처럼 헤더에 토큰을 넣어 보낼 것이다.
jwt.verify 메서드로 토큰을 검증할 수 있다.
메서드의 첫 번째 인수로는 토큰을, 두 번째 인수로는 토큰의 비밀 키를 넣는다.

토큰의 비밀 키가 일치하지 않는다면 인증을 받을 수 없다.
그런 경우에는 에러가 발생하여 catch 문으로 이동하게 된다.
또한, 올바른 토큰이라도 유호 기간이 지난 경우라면 역시 catch 문으로 이동한다.
유효 기간 만료 시 419 상태 코드를 응답하는데, 코드는 400 번대 숫자 둥에서 마음대로 정해도 된다.

인증에 성공한 경우에는 토큰의 내용이 반환되어 req.decoded 에 저장된다.
토큰의 내용은 조금 전에 넣은 사용자 아이디와 닉네임, 발급자, 유효 기간 등이다.
req.decoded 를 통해 다음 미들웨어에서 토큰의 내용물을 사용할 수 있다.

